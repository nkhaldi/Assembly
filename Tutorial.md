# Язык ассемблера. Команды и инструкции

### [Указатель по командам Intel x86](http://www.mathemainzel.info/files/x86asmref.html)

### [Официальная документация от Intel](http://www.intel.com/content/dam/www/public/us/en/documents/manuals/64-ia-32-architectures-software-developer-manual-325462.pdf)

## Общие команды
### Переместить значение в ячейку память
Значение перемещается из `src` в `dst`
```asm
mov dst, src
```
Для примера будем использовать регистры `ax` и `bx`.<br>
Можно перемещать значения между регистрами и между регистром и памятью,<br>
но нельзя перемещать из памяти в память.

#### Примеры
Положить значение 3 в регистр `ax`
```asm
mov ax, 3       ; ax = 3
```
Переместить содержимое регистра `bx` в регистр `ax`
```asm
mov ax, bx      ; ax = bx
```
Переместить содержимое регистра `bx` увеличенное на 3 в регистр `ax`
```asm
mov ax, bx + 3  ; ax = bx + 3
```
Переместить значение, которое лежит по адресу `bx` в регистр `ax`
```asm
mov ax, [bx]    ; ax = *bx
```

### Сложение
Положить в регистр ax значение `ax + bx`.
```asm
add ax, bx  ; ax = ax + bx
```

### Вычитание
Положить в регистр ax значение `ax - bx`.
```asm
add ax, bx  ; ax = ax - bx
```

### Инкремент и декремент
Положить в регигистр ax значение `ax + 1`.
```asm
inc ax      ; ax++
```
Положить в регигистр ax значение `ax - 1`.
```asm
dec ax      ; ax--
```

## Передача управления

#### Пример программы
Число в комментариях справа от команд указывает адрес ячейки памяти,
где может хранится команда.
```asm
    add ax, 3       ; 1
    sub bx, ax      ; 2
label:              ; метка - имя следующей ячейки памяти (3)
    inc bx          ; 3
    ; ...
    ret
loop:               ; цикл
```

### Передача управления с `jmp`
```asm
jmp label       ; переход к метке
jmp loop        ; переход к циклу
```

### Передача управления с `call` - вызов функции
При вызове `call` в отличиек от `jmp` сохраняется адрес возврата в стеке.<br>
Набор инструкций, который вызывается с помочью `call`,<br>
должен заканчиваться инструкцией `ret`.<br>
`ret` извлекает из стека адрес возврата и делает по нему переход.
```asm
call label
```

### Передача управления обработчиком прерывания `int`
Выход из обработчика прерывания делается с помощью инструкции `iret`.<br>
```asm
int N
```

### Пример реализации функции
Реализуем функцию add_value(x, y)
В языке C реализация и вызов будут выглядеть так:
```c
int add_value(int x, int y)
{
    return x + y;
}

int main()
{
    int x, y = // ...
    int z = add_value(x, y);
}
```
На языке Ассемблера это примет следующий вид:
```asm
; Загрузка параметров в стек
push y
push x

; Вызов функции
call add_value
jmp end

; Определение функции
add_value:
    pop eax     ; достали из стека x и записали в eax
    pop ebx     ; достали из стека y и записали в ebx
add aex, abx    ; поместили в eax значение eax + ebx
    ret         ; выход из функции
; Завершение
end:
    nop
```

## Флаги и условные переходы

### Флаги
#### `CF` - устанавливается в `1`, когда произошел перенос в старший разряд
#### `ZF` - устанавливается в `1`, когда в результате операции получили 0

### Сравнение
Изменияет регистр флагов в зависимости от результата.
`cmp` работает аналогично `sub`.
```asm
cmp ax, bx      ; сравнивается значения в регистрах ax и bx
```
Далее можно использовать вариации инструкции `jmp`:

### Команды условного перехода
#### `je` и `jz` - переход, если "равно"
Выполняется, если сравниваемые значения равны `ax == bx`, то есть `ZF = 1`
```asm
je      ; Jump if Equal
jz      ; Jump if ZF
```

#### `jne` и `jnz` - переход, если "не равно"
Выполняется, если сравниваемые значения не равны `ax != bx`, то есть `ZF = 0`
```asm
jne     ; Jump if Not Equal
jnz     ; Jump if Not ZF
```

#### `jc`, `jb`, `jnae` - переход, если "ниже" (есть перенос)
Выполняется, если "ниже" `ax < bx`, то есть перенос и `CF = 1`
```asm
jc      ; Jump if C
jb      ; Jump if Bellow
jnae    ; Jump if Not Above or Equal
```

#### `jnc`, `jnb`, `jae` - переход, если "не ниже" (нет переноса)
Выполняется, если "не ниже" `ax >= bx`, то есть нет переноса и `CF = 0`
```asm
jnc     ; Jump if Not CF
jnb     ; Jump if Not Bellow
jae     ; Jump if Above or Equal
```

#### `ja`, `jnbe` - переход, если "выше"
Выполняется, если "выше" `ax > bx`, то есть `CF = 0` и `ZF = 0`
```asm
ja      ; Jump if Above
jnbe    ; Jump if Not Bellow or Equal
```

#### `jna`, `jbe` - переход, если "выше"
Выполняется, если "не выше" `ax <= bx`, то есть `CF = 1` и `ZF = 1`
```asm
jna     ; Jump if Not Above
jbe     ; Jump if Bellow or Equal
```

#### `jg`, `jnle` - переход, если больше
Выполняется, если "больше" `ax > bx`, то есть `ZF = 0` и `SF = OF`
```asm
jg      ; Jump if Greater
jnle    ; Jump if Not Less or Equal
```

#### `jl`, `jnge` - переход, если меньше
Выполняется, если "меньше" `ax < bx`, то есть `SF != OF`
```asm
jl      ; Jump if Less
jnge    ; Jump if Not Greater or Equal
```

#### `jge`, `jnl` - переход, если больше или равно
Выполняется, если "больше или равно" `ax >= bx`, то есть `SF = OF`
```asm
jge     ; Jump if Greater or Equal
jnl     ; Jump if Not Less
```

#### `jle`, `jng` - переход, если меньше или равно
Выполняется, если "меньше или равно" `ax <= bx`, то есть `ZF = 1` и `SF != OF`
```asm
jle     ; Jump if Less or Equal
jng     ; Jump if Not Greater
```

#### `js` и `jns` - переход по знаку
Выполняется `js`, если флаг `SF = 1`, и `jns`, если флаг `SF = 0`
```asm
js      ; Jump if Sign
jns     ; Jump if Not Sign
```

#### `jo` и `jno` - переход по переполнению
Выполняется `jo`, если флаг `OF = 1`, и `jno`, если флаг `OF = 0`
```asm
jo      ; Jump if Overflow
jno     ; Jump if Not Overflow
```

#### `jp` и `jpe` - переход, если есть паритет или паритет четный
Выполняется, если есть есть паритет или паритет четный, то есть флаг `PF = 1`
```asm
jp      ; Jump if Parity
jpe     ; Jump if Parity is Even
```

#### `jnp` и `jpo` - переход, если нет паритета или паритет нечетный
Выполняется, если есть нет паритета или паритет нечетный, то есть флаг `PF = 0`
```asm
jnp     ; Jump if Not Parity
jpo     ; Jump if Parity is Odd
```

### Примеры
В языках высокого уровня конструкция условного перехода выглядит так:
```c
if (ax == bx) {
    // do 1
} else if (ax > bx) {
    // do 2
} else {
    // do 3
}
// do 4
```
Аналогичная конструкия на языке ассемблера будет выглядеть следующим образом:
```asm
    cmp ax, bx
    je EQUAL       ; ax == bx
    jg GREATER     ; ax > bx
    jmp LESS       ; ax < bx
EQUAL:
    ; do 1
GREATER:
    ; do 2
LESS:
    ; do 3
ENDIF:
    ; do 4
```

## Отличие синтаксисов Intel и AT&T
```
_____________________________________________________________________
| Выражение         | Intel                 | AT&T                  |
|___________________|_______________________|_______________________|
| instr(dst, src)   | instr dst src         | instr src, dst        |
| 20                | 20h                   | 0x20                  |
| eax = ebx + 20    | mov eax,[ebx+20h]     | mov 0x20(%ebx), %eax  |
| eax = 8           | mov eax, 8            | mov $8, %eax          |
| stack.push(eax)   | push eax              | push %eax             |
| eax = stack.pop() | pop eax               | pop %eax              |
| eax = eax + ebx   | add eax, ebx          | add %ebx, %eax        |
| eax = eax - 3     | sub 3, eax            | sub $3, %eax          |
| // comment        | ; comment             | # comment             |
|___________________|_______________________|_______________________|
```
